/*
 * Workflow Execution Service
 *
 * *Run standard workflows on workflow execution platforms in a platform-agnostic way.* ## Executive Summary The Workflow Execution Service (WES) API provides a standard way for users to submit workflow requests to workflow execution systems, and to monitor their execution. This API lets users run a single workflow (currently [**CWL**](https://www.commonwl.org/) or [**WDL**](http://www.openwdl.org/) formatted workflows, other types may be supported in the future) on multiple different platforms, clouds, and environments. Key features of the API: + can request that a workflow be run + can pass parameters to that workflow (e.g. input files, cmdline arguments) + can get information about running workflows (e.g. status, errors, output file locations) + can cancel a running workflow 
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`cancel_run`]
#[derive(Clone, Debug)]
pub struct CancelRunParams {
    /// 
    pub run_id: String
}

/// struct for passing parameters to the method [`get_run_log`]
#[derive(Clone, Debug)]
pub struct GetRunLogParams {
    /// 
    pub run_id: String
}

/// struct for passing parameters to the method [`get_run_status`]
#[derive(Clone, Debug)]
pub struct GetRunStatusParams {
    /// 
    pub run_id: String
}

/// struct for passing parameters to the method [`get_task`]
#[derive(Clone, Debug)]
pub struct GetTaskParams {
    /// 
    pub run_id: String,
    /// 
    pub task_id: String
}

/// struct for passing parameters to the method [`list_runs`]
#[derive(Clone, Debug)]
pub struct ListRunsParams {
    /// OPTIONAL The preferred number of workflow runs to return in a page. If not provided, the implementation should use a default page size. The implementation must not return more items than `page_size`, but it may return fewer.  Clients should not assume that if fewer than `page_size` items are returned that all items have been returned.  The availability of additional pages is indicated by the value of `next_page_token` in the response.
    pub page_size: Option<i64>,
    /// OPTIONAL Token to use to indicate where to start getting results. If unspecified, return the first page of results.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`list_tasks`]
#[derive(Clone, Debug)]
pub struct ListTasksParams {
    /// 
    pub run_id: String,
    /// OPTIONAL The preferred number of task logs to return in a page. If not provided, the implementation should use a default page size. The implementation must not return more items than `page_size`, but it may return fewer.  Clients should not assume that if fewer than `page_size` items are returned that all items have been returned.  The availability of additional pages is indicated by the value of `next_page_token` in the response.
    pub page_size: Option<i64>,
    /// OPTIONAL Token to use to indicate where to start getting results. If unspecified, return the first page of results.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`run_workflow`]
#[derive(Clone, Debug)]
pub struct RunWorkflowParams {
    pub workflow_params: Option<String>,
    pub workflow_type: Option<String>,
    pub workflow_type_version: Option<String>,
    pub tags: Option<String>,
    pub workflow_engine: Option<String>,
    pub workflow_engine_version: Option<String>,
    pub workflow_engine_parameters: Option<String>,
    pub workflow_url: Option<String>,
    /// 
    pub workflow_attachment: Option<Vec<std::path::PathBuf>>
}


/// struct for typed errors of method [`cancel_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelRunError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_run_log`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRunLogError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_run_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRunStatusError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_task`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetTaskError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_runs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRunsError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_tasks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTasksError {
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status404(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_workflow`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunWorkflowError {
    Status400(models::ErrorResponse),
    Status401(models::ErrorResponse),
    Status403(models::ErrorResponse),
    Status500(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}


/// Cancel a running workflow.
pub async fn cancel_run(configuration: &configuration::Configuration, params: CancelRunParams) -> Result<models::RunId, Error<CancelRunError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let run_id = params.run_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/runs/{run_id}/cancel", local_var_configuration.base_path, run_id=crate::apis::urlencode(run_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CancelRunError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint provides detailed information about a given workflow run. The returned result has information about the outputs produced by this workflow (if available), a log object which allows the stderr and stdout to be retrieved, a log array so stderr/stdout for individual tasks can be retrieved, and the overall state of the workflow run (e.g. RUNNING, see the State section).
pub async fn get_run_log(configuration: &configuration::Configuration, params: GetRunLogParams) -> Result<models::RunLog, Error<GetRunLogError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let run_id = params.run_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/runs/{run_id}", local_var_configuration.base_path, run_id=crate::apis::urlencode(run_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRunLogError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This provides an abbreviated (and likely fast depending on implementation) status of the running workflow, returning a simple result with the  overall state of the workflow run (e.g. RUNNING, see the State section).
pub async fn get_run_status(configuration: &configuration::Configuration, params: GetRunStatusParams) -> Result<models::RunStatus, Error<GetRunStatusError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let run_id = params.run_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/runs/{run_id}/status", local_var_configuration.base_path, run_id=crate::apis::urlencode(run_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetRunStatusError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint provides a mechanism to retrieve information on a specific task, if it exists
pub async fn get_task(configuration: &configuration::Configuration, params: GetTaskParams) -> Result<models::TaskLog, Error<GetTaskError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let run_id = params.run_id;
    let task_id = params.task_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/runs/{run_id}/tasks/{task_id}", local_var_configuration.base_path, run_id=crate::apis::urlencode(run_id), task_id=crate::apis::urlencode(task_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetTaskError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This list should be provided in a stable ordering. (The actual ordering is implementation dependent.) When paging through the list, the client should not make assumptions about live updates, but should assume the contents of the list reflect the workflow list at the moment that the first page is requested.  To monitor a specific workflow run, use GetRunStatus or GetRunLog.
pub async fn list_runs(configuration: &configuration::Configuration, params: ListRunsParams) -> Result<models::RunListResponse, Error<ListRunsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let page_size = params.page_size;
    let page_token = params.page_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/runs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListRunsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint provides a paginated list of tasks that were executed as part of a given workflow run. Task ordering should be the same as what would be returned in a `RunLog` response body.
pub async fn list_tasks(configuration: &configuration::Configuration, params: ListTasksParams) -> Result<models::TaskListResponse, Error<ListTasksError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let run_id = params.run_id;
    let page_size = params.page_size;
    let page_token = params.page_token;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/runs/{run_id}/tasks", local_var_configuration.base_path, run_id=crate::apis::urlencode(run_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = page_size {
        local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = page_token {
        local_var_req_builder = local_var_req_builder.query(&[("page_token", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListTasksError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This endpoint creates a new workflow run and returns a `RunId` to monitor its progress. The `workflow_attachment` array may be used to upload files that are required to execute the workflow, including the primary workflow, tools imported by the workflow, other files referenced by the workflow, or files which are part of the input.  The implementation should stage these files to a temporary directory and execute the workflow from there. These parts must have a Content-Disposition header with a \"filename\" provided for each part.  Filenames may include subdirectories, but must not include references to parent directories with '..' -- implementations should guard against maliciously constructed filenames. The `workflow_url` is either an absolute URL to a workflow file that is accessible by the WES endpoint, or a relative URL corresponding to one of the files attached using `workflow_attachment`. The `workflow_params` JSON object specifies input parameters, such as input files.  The exact format of the JSON object depends on the conventions of the workflow language being used.  Input files should either be absolute URLs, or relative URLs corresponding to files uploaded using `workflow_attachment`.  The WES endpoint must understand and be able to access URLs supplied in the input.  This is implementation specific. The `workflow_type` is the type of workflow language and must be \"CWL\" or \"WDL\" currently (or another alternative  supported by this WES instance). The `workflow_type_version` is the version of the workflow language submitted and must be one supported by this WES instance. The `workflow_engine` is the engine that supports the workflow_type and must be supported by this WES instance. The `workflow_engine_version` is the version of workflow engine and must be supported by this WES instance. See the `RunRequest` documentation for details about other fields.
pub async fn run_workflow(configuration: &configuration::Configuration, params: RunWorkflowParams) -> Result<models::RunId, Error<RunWorkflowError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let workflow_params = params.workflow_params;
    let workflow_type = params.workflow_type;
    let workflow_type_version = params.workflow_type_version;
    let tags = params.tags;
    let workflow_engine = params.workflow_engine;
    let workflow_engine_version = params.workflow_engine_version;
    let workflow_engine_parameters = params.workflow_engine_parameters;
    let workflow_url = params.workflow_url;
    let workflow_attachment = params.workflow_attachment;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/runs", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    let mut local_var_form = reqwest::multipart::Form::new();
    if let Some(local_var_param_value) = workflow_params {
        local_var_form = local_var_form.text("workflow_params", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = workflow_type {
        local_var_form = local_var_form.text("workflow_type", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = workflow_type_version {
        local_var_form = local_var_form.text("workflow_type_version", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = tags {
        local_var_form = local_var_form.text("tags", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = workflow_engine {
        local_var_form = local_var_form.text("workflow_engine", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = workflow_engine_version {
        local_var_form = local_var_form.text("workflow_engine_version", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = workflow_engine_parameters {
        local_var_form = local_var_form.text("workflow_engine_parameters", local_var_param_value.to_string());
    }
    if let Some(local_var_param_value) = workflow_url {
        local_var_form = local_var_form.text("workflow_url", local_var_param_value.to_string());
    }
    // TODO: support file upload for 'workflow_attachment' parameter
    local_var_req_builder = local_var_req_builder.multipart(local_var_form);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RunWorkflowError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

