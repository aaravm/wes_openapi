/*
 * Workflow Execution Service
 *
 * *Run standard workflows on workflow execution platforms in a platform-agnostic way.* ## Executive Summary The Workflow Execution Service (WES) API provides a standard way for users to submit workflow requests to workflow execution systems, and to monitor their execution. This API lets users run a single workflow (currently [**CWL**](https://www.commonwl.org/) or [**WDL**](http://www.openwdl.org/) formatted workflows, other types may be supported in the future) on multiple different platforms, clouds, and environments. Key features of the API: + can request that a workflow be run + can pass parameters to that workflow (e.g. input files, cmdline arguments) + can get information about running workflows (e.g. status, errors, output file locations) + can cancel a running workflow 
 *
 * The version of the OpenAPI document: 1.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;

/// State : State can take any of the following values:    + UNKNOWN: The state of the task is unknown. This provides a safe default for messages where this field is missing, for example, so that a missing field does not accidentally imply that the state is QUEUED.    + QUEUED: The task is queued.    + INITIALIZING: The task has been assigned to a worker and is currently preparing to run. For example, the worker may be turning on, downloading input files, etc.    + RUNNING: The task is running. Input files are downloaded and the first Executor has been started.    + PAUSED: The task is paused. An implementation may have the ability to pause a task, but this is not required.    + COMPLETE: The task has completed running. Executors have exited without error   and output files have been successfully uploaded.    + EXECUTOR_ERROR: The task encountered an error in one of the Executor processes. Generally, this means that an Executor exited with a non-zero exit code.    + SYSTEM_ERROR: The task was stopped due to a system error, but not from an Executor, for example an upload failed due to network issues, the worker's ran out of disk space, etc.    + CANCELED: The task was canceled by the user.    + CANCELING: The task was canceled by the user, and is in the process of stopping.    + PREEMPTED: The task is stopped (preempted) by the system. The reasons for this would be tied to the specific system running the job. Generally, this means that the system reclaimed the compute capacity for reallocation. 
/// State can take any of the following values:    + UNKNOWN: The state of the task is unknown. This provides a safe default for messages where this field is missing, for example, so that a missing field does not accidentally imply that the state is QUEUED.    + QUEUED: The task is queued.    + INITIALIZING: The task has been assigned to a worker and is currently preparing to run. For example, the worker may be turning on, downloading input files, etc.    + RUNNING: The task is running. Input files are downloaded and the first Executor has been started.    + PAUSED: The task is paused. An implementation may have the ability to pause a task, but this is not required.    + COMPLETE: The task has completed running. Executors have exited without error   and output files have been successfully uploaded.    + EXECUTOR_ERROR: The task encountered an error in one of the Executor processes. Generally, this means that an Executor exited with a non-zero exit code.    + SYSTEM_ERROR: The task was stopped due to a system error, but not from an Executor, for example an upload failed due to network issues, the worker's ran out of disk space, etc.    + CANCELED: The task was canceled by the user.    + CANCELING: The task was canceled by the user, and is in the process of stopping.    + PREEMPTED: The task is stopped (preempted) by the system. The reasons for this would be tied to the specific system running the job. Generally, this means that the system reclaimed the compute capacity for reallocation. 
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum State {
    #[serde(rename = "UNKNOWN")]
    Unknown,
    #[serde(rename = "QUEUED")]
    Queued,
    #[serde(rename = "INITIALIZING")]
    Initializing,
    #[serde(rename = "RUNNING")]
    Running,
    #[serde(rename = "PAUSED")]
    Paused,
    #[serde(rename = "COMPLETE")]
    Complete,
    #[serde(rename = "EXECUTOR_ERROR")]
    ExecutorError,
    #[serde(rename = "SYSTEM_ERROR")]
    SystemError,
    #[serde(rename = "CANCELED")]
    Canceled,
    #[serde(rename = "CANCELING")]
    Canceling,
    #[serde(rename = "PREEMPTED")]
    Preempted,

}

impl ToString for State {
    fn to_string(&self) -> String {
        match self {
            Self::Unknown => String::from("UNKNOWN"),
            Self::Queued => String::from("QUEUED"),
            Self::Initializing => String::from("INITIALIZING"),
            Self::Running => String::from("RUNNING"),
            Self::Paused => String::from("PAUSED"),
            Self::Complete => String::from("COMPLETE"),
            Self::ExecutorError => String::from("EXECUTOR_ERROR"),
            Self::SystemError => String::from("SYSTEM_ERROR"),
            Self::Canceled => String::from("CANCELED"),
            Self::Canceling => String::from("CANCELING"),
            Self::Preempted => String::from("PREEMPTED"),
        }
    }
}

impl Default for State {
    fn default() -> State {
        Self::Unknown
    }
}

